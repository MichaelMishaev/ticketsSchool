/**
 * OpenTelemetry Configuration for Next.js 15
 *
 * Provides distributed tracing, metrics, and custom spans for critical operations.
 *
 * Usage:
 *   - Automatically initialized via instrumentation.ts hook
 *   - Auto-instruments HTTP, Prisma, fetch
 *   - Custom spans: tracer.startActiveSpan(name, callback)
 *
 * Environment Variables:
 *   - OTEL_SERVICE_NAME: Service identifier (default: "ticketcap")
 *   - OTEL_ENVIRONMENT: Environment (production, staging, development)
 *   - OTEL_EXPORTER_OTLP_ENDPOINT: OTLP endpoint (Grafana Cloud or Jaeger)
 *   - OTEL_EXPORTER_OTLP_HEADERS: Auth headers (Base64 credentials)
 *   - OTEL_TRACES_SAMPLER_ARG: Sample rate (1.0 = 100%, 0.1 = 10%)
 */

import { NodeSDK } from '@opentelemetry/sdk-node'
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node'
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http'
import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics'
import { Resource } from '@opentelemetry/resources'
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'
import { trace, context, SpanStatusCode } from '@opentelemetry/api'

// Global SDK instance
let sdk: NodeSDK | null = null

/**
 * Initialize OpenTelemetry SDK
 * Called automatically by instrumentation.ts hook
 */
export function initTelemetry() {
  if (sdk) {
    console.warn('OpenTelemetry already initialized')
    return
  }

  const serviceName = process.env.OTEL_SERVICE_NAME || 'ticketcap'
  const environment = process.env.OTEL_ENVIRONMENT || process.env.NODE_ENV || 'development'
  const otlpEndpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318'
  const otlpHeaders = process.env.OTEL_EXPORTER_OTLP_HEADERS || ''
  const sampleRate = parseFloat(process.env.OTEL_TRACES_SAMPLER_ARG || '1.0')

  // Parse OTLP headers (format: "key1=value1,key2=value2")
  const headers: Record<string, string> = {}
  if (otlpHeaders) {
    otlpHeaders.split(',').forEach((header) => {
      const [key, value] = header.split('=')
      if (key && value) {
        headers[key.trim()] = value.trim()
      }
    })
  }

  // Resource attributes (service metadata)
  const resource = new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: serviceName,
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.SENTRY_RELEASE || 'unknown',
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: environment,
  })

  // Trace exporter (OTLP HTTP)
  const traceExporter = new OTLPTraceExporter({
    url: `${otlpEndpoint}/v1/traces`,
    headers,
  })

  // Metric exporter (OTLP HTTP)
  const metricExporter = new OTLPMetricExporter({
    url: `${otlpEndpoint}/v1/metrics`,
    headers,
  })

  // Metric reader (periodic export every 60 seconds)
  const metricReader = new PeriodicExportingMetricReader({
    exporter: metricExporter,
    exportIntervalMillis: parseInt(process.env.OTEL_METRIC_EXPORT_INTERVAL || '60000', 10),
  })

  // Initialize SDK
  sdk = new NodeSDK({
    resource,
    traceExporter,
    metricReader,
    instrumentations: [
      getNodeAutoInstrumentations({
        // Auto-instrument common libraries
        '@opentelemetry/instrumentation-http': {
          enabled: true,
          ignoreIncomingRequestHook: (request) => {
            // Ignore health checks and static assets
            const url = request.url || ''
            return (
              url.includes('/api/health') ||
              url.includes('/_next/') ||
              url.includes('/favicon.ico')
            )
          },
        },
        '@opentelemetry/instrumentation-prisma': {
          enabled: true,
        },
        '@opentelemetry/instrumentation-fetch': {
          enabled: true,
        },
      }),
    ],
    // Sampling strategy (reduce cost in production)
    // - parentbased_traceidratio: Sample based on parent span + trace ID
    // - OTEL_TRACES_SAMPLER_ARG: Sample rate (1.0 = 100%, 0.1 = 10%)
    spanProcessors: [], // Use default batch processor
  })

  // Start SDK
  sdk.start()

  console.log(`OpenTelemetry initialized: ${serviceName} (${environment})`)
  console.log(`OTLP Endpoint: ${otlpEndpoint}`)
  console.log(`Sample Rate: ${sampleRate * 100}%`)

  // Graceful shutdown
  process.on('SIGTERM', async () => {
    try {
      await sdk?.shutdown()
      console.log('OpenTelemetry shut down successfully')
    } catch (error) {
      console.error('Error shutting down OpenTelemetry', error)
    }
  })
}

/**
 * Get tracer for custom spans
 *
 * Example:
 *   const tracer = getTracer()
 *   await tracer.startActiveSpan('my-operation', async (span) => {
 *     span.setAttribute('key', 'value')
 *     // ... do work
 *     span.end()
 *   })
 */
export function getTracer(name: string = 'ticketcap') {
  return trace.getTracer(name)
}

/**
 * Record an error in the current span
 *
 * Example:
 *   try {
 *     // ... operation
 *   } catch (error) {
 *     recordError(error, { eventId: '123', userId: '456' })
 *     throw error
 *   }
 */
export function recordError(error: Error, attributes?: Record<string, string | number>) {
  const span = trace.getActiveSpan()
  if (span) {
    span.recordException(error)
    span.setStatus({ code: SpanStatusCode.ERROR, message: error.message })
    if (attributes) {
      span.setAttributes(attributes)
    }
  }
}

/**
 * Create a custom span with automatic error handling
 *
 * Example:
 *   const result = await createSpan('registration.create', async (span) => {
 *     span.setAttribute('eventId', eventId)
 *     const registration = await createRegistration(data)
 *     return registration
 *   })
 */
export async function createSpan<T>(
  name: string,
  callback: (span: any) => Promise<T>,
  attributes?: Record<string, string | number | boolean>
): Promise<T> {
  const tracer = getTracer()
  return await tracer.startActiveSpan(name, async (span) => {
    try {
      if (attributes) {
        span.setAttributes(attributes)
      }
      const result = await callback(span)
      span.setStatus({ code: SpanStatusCode.OK })
      span.end()
      return result
    } catch (error) {
      span.recordException(error as Error)
      span.setStatus({ code: SpanStatusCode.ERROR, message: (error as Error).message })
      span.end()
      throw error
    }
  })
}

/**
 * Trace a registration operation (atomic capacity check + transaction)
 *
 * Example:
 *   const result = await traceRegistration(eventId, spotsCount, async () => {
 *     return await createRegistration(data)
 *   })
 */
export async function traceRegistration<T>(
  eventId: string,
  spotsCount: number,
  callback: () => Promise<T>
): Promise<T> {
  return await createSpan(
    'registration.create',
    async (span) => {
      span.setAttributes({
        'event.id': eventId,
        'registration.spots': spotsCount,
      })

      // Capacity check span
      await createSpan('registration.capacityCheck', async (checkSpan) => {
        // Capacity check happens inside callback (can't access event here)
        checkSpan.setAttribute('operation', 'capacity_check')
      })

      // Execute transaction
      const result = await createSpan('registration.transaction', async (txSpan) => {
        const data = await callback()
        txSpan.setAttribute('operation', 'atomic_transaction')
        return data
      })

      return result
    },
    { operation: 'registration' }
  )
}

/**
 * Trace a payment operation (YaadPay integration)
 *
 * Example:
 *   const payment = await tracePayment(amount, currency, async () => {
 *     return await processPayment(data)
 *   })
 */
export async function tracePayment<T>(
  amount: number,
  currency: string,
  callback: () => Promise<T>
): Promise<T> {
  return await createSpan(
    'payment.process',
    async (span) => {
      span.setAttributes({
        'payment.amount': amount,
        'payment.currency': currency,
        'payment.gateway': 'yaadpay',
      })

      const result = await callback()
      return result
    },
    { operation: 'payment' }
  )
}

/**
 * Trace a database query (use for complex queries not auto-instrumented)
 *
 * Example:
 *   const events = await traceQuery('events', 'findMany', async () => {
 *     return await prisma.event.findMany({ where: { ... } })
 *   })
 */
export async function traceQuery<T>(
  model: string,
  operation: string,
  callback: () => Promise<T>
): Promise<T> {
  return await createSpan(
    `db.${model}.${operation}`,
    async (span) => {
      span.setAttributes({
        'db.model': model,
        'db.operation': operation,
        'db.system': 'postgresql',
      })

      const result = await callback()
      return result
    },
    { operation: 'database_query' }
  )
}

/**
 * Trace an external HTTP call (YaadPay, Resend, etc.)
 *
 * Example:
 *   const response = await traceExternalCall('yaadpay', 'POST', '/api/payment', async () => {
 *     return await fetch('https://yaadpay.co.il/api/payment', { ... })
 *   })
 */
export async function traceExternalCall<T>(
  service: string,
  method: string,
  path: string,
  callback: () => Promise<T>
): Promise<T> {
  return await createSpan(
    `external.${service}.${method}`,
    async (span) => {
      span.setAttributes({
        'http.method': method,
        'http.url': path,
        'external.service': service,
      })

      const result = await callback()
      return result
    },
    { operation: 'external_call' }
  )
}

/**
 * Add custom attributes to the current span
 *
 * Example:
 *   addSpanAttributes({ userId: '123', eventId: '456' })
 */
export function addSpanAttributes(attributes: Record<string, string | number | boolean>) {
  const span = trace.getActiveSpan()
  if (span) {
    span.setAttributes(attributes)
  }
}

/**
 * Add an event to the current span (breadcrumb)
 *
 * Example:
 *   addSpanEvent('capacity_check', { available: 10, requested: 5 })
 */
export function addSpanEvent(name: string, attributes?: Record<string, string | number | boolean>) {
  const span = trace.getActiveSpan()
  if (span) {
    span.addEvent(name, attributes)
  }
}

/**
 * Shutdown OpenTelemetry SDK
 * Called automatically on SIGTERM, but can be called manually for testing
 */
export async function shutdownTelemetry() {
  if (sdk) {
    await sdk.shutdown()
    sdk = null
    console.log('OpenTelemetry shut down')
  }
}
